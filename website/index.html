<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steppe - Composable, self-documenting REST APIs for Ruby</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
    <nav class="top-menu">
        <div class="top-menu-content">
            <div class="top-menu-brand">
                <span class="brand-name">Steppe</span>
                <span class="brand-tagline">Composable REST APIs for Ruby</span>
            </div>
            <a href="https://github.com/ismasan/steppe" target="_blank" class="github-link" aria-label="View on GitHub">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                <span>GitHub</span>
            </a>
        </div>
    </nav>
    <div class="container">
        <nav class="sidebar">
            <div class="logo">
                <h2>Steppe</h2>
                <p class="tagline">REST APIs for Ruby</p>
            </div>
            <ul class="nav-menu">
                <li><a href="#overview">Overview</a></li>
                <li><a href="#usage">Usage</a></li>
                <li class="nav-submenu">
                    <a href="#defining-service">Defining a Service</a>
                </li>
                <li class="nav-submenu">
                    <a href="#defining-endpoints">Defining Endpoints</a>
                </li>
                <li class="nav-submenu">
                    <a href="#query-schemas">Query Schemas</a>
                </li>
                <li class="nav-submenu">
                    <a href="#payload-schemas">Payload Schemas</a>
                </li>
                <li class="nav-submenu">
                    <a href="#pipelines">Pipelines</a>
                </li>
                <li class="nav-submenu">
                    <a href="#file-uploads">File Uploads</a>
                </li>
                <li class="nav-submenu">
                    <a href="#serializers">Serializers</a>
                </li>
                <li class="nav-submenu">
                    <a href="#response-formats">Response Formats</a>
                </li>
                <li class="nav-submenu">
                    <a href="#action-classes">Action Classes</a>
                </li>
                <li class="nav-submenu">
                    <a href="#openapi">OpenAPI Documentation</a>
                </li>
                <li class="nav-submenu">
                    <a href="#integration">Integration</a>
                </li>
                <li class="nav-submenu">
                    <a href="#custom-types">Custom Types</a>
                </li>
                <li class="nav-submenu">
                    <a href="#error-handling">Error Handling</a>
                </li>
                <li class="nav-submenu">
                    <a href="#content-negotiation">Content Negotiation</a>
                </li>
                <li class="nav-submenu">
                    <a href="#header-schemas">Header Schemas</a>
                </li>
                <li class="nav-submenu">
                    <a href="#security">Security Schemes</a>
                </li>
                <li><a href="#installation">Installation</a></li>
                <li><a href="#development">Development</a></li>
                <li><a href="#contributing">Contributing</a></li>
                <li><a href="#license">License</a></li>
            </ul>
        </nav>

        <main class="content">
            <header class="page-header">
                <h1>Steppe</h1>
                <p class="subtitle">Composable, self-documenting REST APIs for Ruby</p>
            </header>

            <section id="overview" class="section">
                <h2>Overview</h2>
                <p>Steppe is a Ruby gem that provides a DSL for building REST APIs with an emphasis on:</p>
                <ul class="feature-list">
                    <li><strong>Composability</strong> - Built on composable pipelines, allowing endpoints to be assembled from reusable, testable validation and processing steps</li>
                    <li><strong>Type Safety & Validation</strong> - Define input schemas for query parameters and request bodies, ensuring data is validated and coerced before reaching business logic</li>
                    <li><strong>Expandable API</strong> - Start with a terse DSL for defining endpoints, and extend with custom steps as needed</li>
                    <li><strong>Self-Documentation</strong> - Automatically generates OpenAPI specifications from endpoint definitions, keeping documentation in sync with implementation</li>
                    <li><strong>Content Negotiation</strong> - Handles multiple response formats through a Responder system that matches status codes and content types</li>
                    <li><strong>Mountable on Rack routers</strong>, and (soon) standalone with its own router</li>
                </ul>
            </section>

            <section id="usage" class="section">
                <h2>Usage</h2>

                <article id="defining-service" class="subsection">
                    <h3>Defining a Service</h3>
                    <p>A Service is a container for API endpoints with metadata:</p>
                    <pre><code>require 'steppe'

Service = Steppe::Service.new do |api|
  api.title = 'Users API'
  api.description = 'API for managing users'
  api.server(
    url: 'http://localhost:4567',
    description: 'Production server'
  )
  api.tag('users', description: 'User management operations')

  # Define endpoints here...
end</code></pre>
                </article>

                <article id="defining-endpoints" class="subsection">
                    <h3>Defining Endpoints</h3>
                    <p>Endpoints define HTTP routes with validation, processing steps, and response serialization:</p>
                    <pre><code># GET endpoint with query parameter validation
api.get :users, '/users' do |e|
  e.description = 'List users'
  e.tags = %w[users]

  # Validate query parameters
  e.query_schema(
    q?: Types::String.desc('Search by name'),
    limit?: Types::Lax::Integer.default(10).desc('Number of results')
  )

  # Business logic step
  e.step do |conn|
    users = User.filter_by_name(conn.params[:q])
                .limit(conn.params[:limit])
    conn.valid users
  end

  # JSON response serialization
  e.json do
    attribute :users, [UserSerializer]

    def users
      object
    end
  end
end</code></pre>
                </article>

                <article id="query-schemas" class="subsection">
                    <h3>Query Schemas</h3>
                    <p>Use <code>#query_schema</code> to register steps to coerce and validate URL path and query parameters.</p>
                    <pre><code>api.get :list_users, '/users' do |e|
  e.description = 'List and filter users'
  # URL path and query parameters will be passed through this schema
  # You can annotate fields with .desc() and .example() to supplement
  # the generated OpenAPI specs
  e.query_schema(
    q?: Types::String.desc('full text search').example('bo, media'),
    status?: Types::String.desc('status filter').options(%w[active inactive])
  )

  # coerced and validated parameters are now
  # available in conn.params
  e.step do |conn|
    users = User
    users = users.search(conn.params[:q]) if conn.params[:q]
    users = users.by_status(conn.params[:status]) if conn.params[:status]
    conn.valid users
  end
end

# GET /users?status=active&q=bob</code></pre>

                    <h4>Path Parameters</h4>
                    <p>URL path parameters are automatically extracted and merged into a default query schema:</p>
                    <pre><code># the presence of path tokens in path, such as :id
# will automatically register #query_schema(id: Types::String)
api.get :user, '/users/:id' do |e|
  e.description = 'Fetch a user by ID'
  e.step do |conn|
    # conn.params[:id] is a string
    user = User.find(conn.params[:id])
    user ? conn.valid(user) : conn.invalid(errors: { id: 'Not found' })
  end

  e.json 200...300, UserSerializer
end</code></pre>

                    <p>You can extend the implicit query schema to add or update individual fields:</p>
                    <pre><code># Override the implicit :id field
# to coerce it to an integer
e.query_schema(
  id: Types::Lax::Integer
)

e.step do |conn|
  # conn.params[:id] is an Integer
  conn.valid conn.params[:id] * 10
end</code></pre>

                    <p>Multiple calls to <code>#query_schema</code> will aggregate into a single <code>Endpoint#query_schema</code>:</p>
                    <pre><code>UsersAPI[:user].query_schema # => Plumb::Types::Hash</code></pre>
                </article>

                <article id="payload-schemas" class="subsection">
                    <h3>Payload Schemas</h3>
                    <p>Use <code>payload_schema</code> to validate request bodies:</p>
                    <pre><code>api.post :create_user, '/users' do |e|
  e.description = 'Create a user'
  e.tags = %w[users]

  # Validate request body
  e.payload_schema(
    user: {
      name: Types::String.desc('User name').example('Alice'),
      email: Types::Email.desc('User email').example('alice@example.com'),
      age: Types::Lax::Integer.desc('User age').example(30)
    }
  )

  # Create user (only runs if payload is valid)
  e.step do |conn|
    user = User.create(conn.params[:user])
    conn.respond_with(201).valid user
  end

  # Serialize response
  e.json 201, UserSerializer
end</code></pre>
                </article>

                <article id="pipelines" class="subsection">
                    <h3>It's Pipelines Steps All the Way Down</h3>
                    <p>Query and payload schemas are themselves steps in the processing pipeline, so you can insert steps before or after each of them.</p>
                    <pre><code># Coerce and validate query parameters
e.query_schema(
  id: Types::Lax::Integer.present
)

# Use (validated, coerced) ID to locate resource
# and do some custom authorization
e.step do |conn|
  user = User.find(conn.params[:id])
  if user.can_update_account?
    conn.continue user
  else
    conn.respond_with(401).halt
  end
end

# Only NOW parse and validate request body
e.payload_schema(
  name: Types::String.present.desc('Account name'),
  email: Types::Email.present.desc('Account email')
)</code></pre>

                    <p>A "step" is an <code>#call(Steppe::Result) => Steppe::Result</code> interface. You can use procs, or you can use your own objects.</p>
                    <pre><code>class FindAndAuthorizeUser
  def self.call(conn)
    user = User.find(conn.params[:id])
    return conn.respond_with(401).halt unless user.can_update_account?

    conn.continue(user)
  end
end

# In your endpoint
e.step FindAndAuthorizeUser</code></pre>

                    <p>It's up to you how/if your custom steps manage their own state (ie. classes vs. instances). You can use instances for configuration, for example.</p>
                    <pre><code># Works as long as the instance responds to #call(Result) => Result
e.step MyCustomAuthorizer.new(role: 'admin')</code></pre>

                    <h4>Halting the Pipeline</h4>
                    <p>A step that returns a <code>Continue</code> result passes the result on to the next step.</p>
                    <pre><code>e.step do |conn|
  conn.continue('hello')
end</code></pre>

                    <p>A step that returns a <code>Halt</code> result signals the pipeline to stop processing.</p>
                    <pre><code># This step halts the pipeline
e.step do |conn|
  conn.halt
  # Or
  # conn.invalid(errors: {name: 'is invalid'})
end

# This step will never run
e.step do |conn|
  # etc
end</code></pre>

                    <h4>Steps with Schemas</h4>
                    <p>A custom step that also supports <code>#query_schema</code>, <code>#payload_schema</code> and <code>#header_schema</code> will have those schemas merged into the endpoint's schemas, which can be used to generate OpenAPI documentation.</p>
                    <pre><code>class CreateUser
  def self.payload_schema = Types::Hash[name: String, age: Types::Integer[18..]]

  def self.call(conn)
    # Instantiate, manage state, run your domain logic, etc
    conn
  end
end

# CreateUser.payload_schema will be merged into the endpoint's own payload_schema
e.step CreateUser

# You can add fields to the payload schema
# The top-level endpoint schema will be the merge of both
e.payload_schema(
  email: Types::Email.present
)</code></pre>
                </article>

                <article id="file-uploads" class="subsection">
                    <h3>File Uploads</h3>
                    <p>Handle file uploads with the <code>UploadedFile</code> type:</p>
                    <pre><code>api.post :upload, '/files' do |e|
  e.payload_schema(
    file: Steppe::Types::UploadedFile.with(type: 'text/plain')
  )

  e.step do |conn|
    file = conn.params[:file]
    # file.tempfile, file.filename, file.type available
    conn.valid(process_file(file))
  end

  e.json 201, FileSerializer
end</code></pre>
                </article>

                <article id="serializers" class="subsection">
                    <h3>Named Serializers</h3>
                    <p>Define reusable serializers:</p>
                    <pre><code>class UserSerializer < Steppe::Serializer
  attribute :id, Types::Integer.example(1)
  attribute :name, Types::String.example('Alice')
  attribute :email, Types::Email.example('alice@example.com')
end

# Use in endpoints
e.json 200, UserSerializer</code></pre>

                    <p>You can also compose serializers together:</p>
                    <pre><code>class UserListSerializer < Steppe::Serializer
  attribute :page, Types::Integer.example(1)
  attribute :users, [UserSerializer]

  def page = conn.params[:page] || 1
  def users = object
end</code></pre>

                    <p>Serializers are based on <a href="https://github.com/ismasan/plumb" target="_blank">Plumb's Data structs</a>.</p>
                </article>

                <article id="response-formats" class="subsection">
                    <h3>Multiple Response Formats</h3>
                    <p>Support multiple content types:</p>
                    <pre><code>api.get :user, '/users/:id' do |e|
  e.step { |conn| conn.valid(User.find(conn.params[:id])) }

  # JSON response
  e.json 200, UserSerializer

  # HTML response (using Papercraft)
  e.html do |conn|
    html5 {
      body {
        h1 conn.value.name
        p "Email: #{conn.value.email}"
      }
    }
  end
end</code></pre>

                    <h4>HTML Templates</h4>
                    <p>HTML templates rely on <a href="https://papercraft.noteflakes.com" target="_blank">Papercraft</a>. It's possible to register your own templating though.</p>
                    <p>You can pass inline templates like in the example above, or named constants pointing to HTML components.</p>
                    <pre><code># Somewhere in your app:
UserTemplate = proc do |conn|
  html5 {
    body {
      h1 conn.value.name
      p "Email: #{conn.value.email}"
    }
  }
end

# In your endpoint
e.html(200..299, UserTemplate)</code></pre>
                </article>

                <article id="action-classes" class="subsection">
                    <h3>Reusable Action Classes</h3>
                    <p>Encapsulate logic in action classes:</p>
                    <pre><code>class UpdateUser
  SCHEMA = Types::Hash[
    name: Types::String.present,
    age: Types::Lax::Integer[18..]
  ]

  def self.payload_schema = SCHEMA

  def self.call(conn)
    user = User.update(conn.params[:id], conn.params)
    conn.valid user
  end
end

# Use in endpoint
api.put :update_user, '/users/:id' do |e|
  e.step UpdateUser
  e.json 200, UserSerializer
end</code></pre>
                </article>

                <article id="openapi" class="subsection">
                    <h3>OpenAPI Documentation</h3>
                    <p>Use a service's <code>#specs</code> helper to mount a GET route to automatically serve OpenAPI schemas from.</p>
                    <pre><code>MyAPI = Steppe::Service.new do |api|
  api.title = 'Users API'
  api.description = 'API for managing users'

  # OpenAPI JSON schemas for this service
  # will be available at GET /schemas (defaults to /)
  api.specs('/schemas')

  # Define API endpoints
  api.get :list_users, '/users' do |e|
    # etc
  end
end</code></pre>

                    <p>Or use the <code>OpenAPIVisitor</code> directly:</p>
                    <pre><code># Get OpenAPI JSON
openapi_spec = Steppe::OpenAPIVisitor.from_request(MyAPI, rack_request)

# Or generate manually
openapi_spec = Steppe::OpenAPIVisitor.call(MyAPI)</code></pre>

                    <div class="image-container">
                        <img src="https://github.com/user-attachments/assets/fea61225-538b-4653-bdd0-9f8b21c8c389" alt="Swagger UI Example" />
                        <p class="caption">Using the Swagger UI tool to view a Steppe API definition</p>
                    </div>
                </article>

                <article id="integration" class="subsection">
                    <h3>Integration with Sinatra</h3>
                    <p>Mount Steppe services in Rack-based applications:</p>
                    <pre><code>require 'sinatra/base'

class App < Sinatra::Base
  MyService.endpoints.each do |endpoint|
    public_send(endpoint.verb, endpoint.path.to_templates.first) do
      resp = endpoint.run(request).response
      resp.finish
    end
  end
end</code></pre>

                    <h4>Mount in Hanami::Router</h4>
                    <p>The excellent and fast Hanami::Router can be used as a standalone router for Steppe services. Or you can mount them into an existing Hanami app.</p>
                    <pre><code># hanami_service.ru
# run with
#   bundle exec rackup ./hanami_service.ru
require 'hanami/router'
require 'rack/cors'

app = MyService.route_with(Hanami::Router.new)

# Or mount within a router block
app = Hanami::Router.new do
  scope '/api' do
    MyService.route_with(self)
  end
end

# Allowing all origins
# to make Swagger UI work
use Rack::Cors do
  allow do
    origins '*'
    resource '*', headers: :any, methods: :any
  end
end

run app</code></pre>
                    <p>See <code>examples/hanami.ru</code></p>
                </article>

                <article id="custom-types" class="subsection">
                    <h3>Custom Types</h3>
                    <p>Define custom validation types using <a href="https://github.com/ismasan/plumb" target="_blank">Plumb</a>:</p>
                    <pre><code>module Types
  include Plumb::Types

  UserCategory = String
    .options(%w[admin customer guest])
    .default('guest')
    .desc('User category')

  DowncaseString = String.invoke(:downcase)
end

# Use in schemas
e.query_schema(
  category?: Types::UserCategory
)</code></pre>
                </article>

                <article id="error-handling" class="subsection">
                    <h3>Error Handling</h3>
                    <p>Endpoints automatically handle validation errors with 422 responses. Customize error responses:</p>
                    <pre><code>e.json 422 do
  attribute :errors, Types::Hash

  def errors
    object
  end
end</code></pre>
                </article>

                <article id="content-negotiation" class="subsection">
                    <h3>Content Negotiation</h3>
                    <p>The <code>#json</code> and <code>#html</code> Endpoint methods are shortcuts for <code>Responder</code> objects that can be tailored to specific combinations of request accepted content types, and response status.</p>
                    <pre><code># equivalent to e.json(200, UserSerializer)
e.respond 200, :json do |r|
  r.description = "JSON response"
  r.serialize UserSerializer
end</code></pre>

                    <p>Responders switch their serializer type depending on their resulting content type.</p>
                    <p>This is a responder that accepts HTML requests, and responds with JSON.</p>
                    <pre><code>e.respond statuses: 200..299, accepts: :html, content_type: :json do |r|
  # Using an inline JSON serializer this time
  e.serialize do
    attribute :name, String
    attribute :age, Integer
  end
end</code></pre>

                    <p>Responders can accept wildcard media types, and an endpoint can define multiple responders, from more to less specific.</p>
                    <pre><code>e.respond 200, :json, UserSerializer
e.respond 200, 'text/*', UserTextSerializer</code></pre>
                </article>

                <article id="header-schemas" class="subsection">
                    <h3>Header Schemas</h3>
                    <p><code>Endpoint#header_schema</code> is similar to <code>#query_schema</code> and <code>#payload_schema</code>, and it allows to define schemas to validate and/or coerce request headers.</p>
                    <pre><code>api.get :list_users, '/users' do |e|
  # Coerce some expected request headers
  # This coerces the APIVersion header to a number
  e.header_schema(
    'APIVersion' => Steppe::Types::Lax::Numeric
  )

  # Downstream handlers will get a numeric header value
  e.step do |conn|
    Logger.info conn.request.env['APIVersion'] # a number
    conn
  end
end</code></pre>

                    <p>These header schemas are inclusive: they don't remove other headers not included in the schemas.</p>
                    <p>They also generate OpenAPI docs.</p>

                    <div class="image-container">
                        <img src="https://github.com/user-attachments/assets/c25e65f7-8733-42d9-a1b6-b93d815e2981" alt="Header Schema in Swagger UI" />
                    </div>

                    <h4>Header Schema Order Matters</h4>
                    <p>Like most things in Steppe, query schemas are registered as steps in a pipeline, so the order of registration matters.</p>
                    <pre><code># No header schema coercion yet, the header is a string here.
e.step do |conn|
  Logger.info conn.request.env['APIVersion'] # a STRING
  conn
end

# Register the schema as a step in the endpoint's pipeline
e.header_schema(
    'APIVersion' => Steppe::Types::Lax::Numeric
)

# By the time this new step runs
# the header schema above has coerced the headers
e.step do |conn|
  Logger.info conn.request.env['APIVersion'] # a NUMBER
  conn
end</code></pre>

                    <h4>Multiple Header Schemas</h4>
                    <p>Like with <code>#query_schema</code> and <code>#payload_schema</code>, <code>#header_schema</code> can be invoked multiple times, which will register individual validation steps, but it will also merge those schemas into the top-level <code>Endpoint#header_schema</code>, which goes into OpenAPI docs.</p>
                    <pre><code>api.get :list_users, '/users' do |e|
  e.header_schema('ApiVersion' => Steppe::Types::Lax::Numeric)
  # some more steps
  e.step SomeHandler
  # add to endpoint's header schema
  e.header_schema('HTTP_AUTHORIZATION' => JWTParser)
  # more steps ...
end

# Endpoint's header_schema includes all fields
UserAPI[:list_users].header_schema
# is a
Steppe::Types::Hash[
   'ApiVersion' => Steppe::Types::Lax::Numeric,
   'HTTP_AUTHORISATION' => JWTParser
]</code></pre>

                    <h4>Header Schema Composition</h4>
                    <p>Custom steps that define their own <code>#header_schema</code> will also have their schemas merged into the endpoint's <code>#header_schema</code>, and automatically documented in OpenAPI.</p>
                    <pre><code>class ListUsersAction
  HEADER_SCHEMA = Steppe::Types::Hash['ClientVersion' => String]

  # responding to this method will cause
  # Steppe to merge this schema into the endpoint's
  def header_schema = HEADER_SCHEMA

  # The Step interface to handle requests
  def call(conn)
    Logger.info conn.request.env['ClientVersion']
    # do something
    users = User.page(conn.params[:page])
    conn.valid users
  end
end</code></pre>
                </article>

                <article id="security" class="subsection">
                    <h3>Security Schemes (Authentication and Authorization)</h3>
                    <p>Steppe follows the same design as <a href="https://swagger.io/docs/specification/v3_0/authentication/" target="_blank">OpenAPI security schemes</a>.</p>
                    <p>A service defines one or more security schemes, which can then be opted-in either by individual endpoints, or for all endpoints at once.</p>
                    <p>Steppe provides two built-in schemes: <strong>Bearer token</strong> authentication (with scopes) and <strong>Basic</strong> HTTP authentication. More coming later.</p>
                    <pre><code>UsersAPI = Steppe::Service.new do |api|
  api.title = 'Users API'
  api.description = 'API for managing users'
  api.server(
    url: 'http://localhost:9292',
    description: 'local server'
  )

  # Bearer token authentication with scopes
  api.bearer_auth(
    'BearerToken',
    store: {
      'admintoken' => %w[users:read users:write],
      'publictoken' => %w[users:read],
    }
  )

  # Basic HTTP authentication (username/password)
  api.basic_auth(
    'BasicAuth',
    store: {
      'admin' => 'secret123',
      'user' => 'password456'
    }
  )

  # Endpoint definitions here
  api.get :list_users, '/users' do |e|
    # etc
  end

  api.post :create_user, '/users' do |e|
    # etc
  end
end</code></pre>

                    <h4>Per-endpoint Security</h4>
                    <pre><code># Each endpoint can opt-in to using registered security schemes
api.get :list_users, '/users' do |e|
  e.description = 'List users'

  # Bearer auth with scopes
  e.security 'BearerToken', ['users:read']
  # etc
end

api.post :create_user, '/users' do |e|
  e.description = 'Create user'

  # Basic auth (no scopes)
  e.security 'BasicAuth'
  # etc
end</code></pre>

                    <h4>Service-level Security</h4>
                    <p>Using the <code>#security</code> method at the service level registers that scheme for all endpoints defined after that:</p>
                    <pre><code>UsersAPI = Steppe::Service.new do |api|
  # etc
  # Define the security scheme
  api.bearer_auth('BearerToken', ...)

  # Now apply the scheme to all endpoints in this service, with the same scopes
  api.security 'BearerToken', ['users:read']

  # all endpoints here enforce a bearer token with scope 'users:read'
  api.get :list_users, '/users'
  api.post :create_user, '/users'
  # etc
end</code></pre>

                    <p>Note that the order of the <code>security</code> invocation matters. The following example defines an un-authenticated <code>:root</code> endpoint, and then protects all further endpoints with the 'BearerToken' scheme.</p>
                    <pre><code>api.get :root, '/' # <= public endpoint

api.security 'BearerToken', ['users:read'] # <= applies to all endpoints after this

api.get :list_users, '/users'
api.post :create_user, '/users'</code></pre>

                    <h4>Automatic OpenAPI Docs</h4>
                    <p>The OpenAPI endpoint mounted via <code>api.specs('/openapi.json')</code> will include these security schemas.</p>

                    <div class="image-container">
                        <img src="https://github.com/user-attachments/assets/3bdecb81-8248-4437-a78a-c80dd7d44ebd" alt="Security Schemes in Swagger UI" />
                    </div>

                    <h4>Custom Security Schemes</h4>
                    <p><code>Service#bearer_auth</code> and <code>#basic_auth</code> are shortcuts to register built-in security schemes. You can use <code>Service#security_scheme</code> to register custom implementations.</p>
                    <pre><code>api.security_scheme MyCustomAuthentication.new(name: 'BulletProof')</code></pre>

                    <p>The custom security scheme is expected to implement the following interface:</p>
                    <pre><code>#name() => String
#handle(Steppe::Result, endpoint_expected_scopes) => Steppe::Result
#to_openapi() => Hash</code></pre>

                    <p>An example:</p>
                    <pre><code>class MyCustomAuthentication
  HEADER_NAME = 'X-API-Key'

  attr_reader :name

  def initialize(name:)
    @name = name
  end

   # @param conn [Steppe::Result::Continue]
   # @param endpoint_scopes [Array&lt;String&gt;] scopes expected by this endpoint (if any)
   # @return [Steppe::Result::Continue, Steppe::Result::Halt]
  def handle(conn, _endpoint_scopes)
     api_token = conn.request.env[HEADER_NAME]
     return conn.respond_with(401).halt if api_token.nil?

     return conn.respond_with(403).halt if api_token != 'super-secure-token'

     # all good, continue handling the request
     conn
  end

  # This data will be included in the OpenAPI specification
  # for this security scheme
  # @see https://swagger.io/docs/specification/v3_0/authentication/
  # @return [Hash]
  def to_openapi
    {
      'type' => 'apiKey',
      'in' => 'header',
      'name' => HEADER_NAME
    }
  end
end</code></pre>

                    <p>Security schemes can optionally implement <code>#query_schema</code>, <code>#payload_schemas</code> and <code>#header_schema</code>, which will be merged onto the endpoint's equivalents, and automatically added to OpenAPI documentation.</p>
                </article>
            </section>

            <section id="installation" class="section">
                <h2>Installation</h2>
                <p>Add the gem to your application's Gemfile by executing:</p>
                <pre><code>$ bundle add steppe</code></pre>
                <p>If bundler is not being used to manage dependencies, install the gem by executing:</p>
                <pre><code>$ gem install steppe</code></pre>
            </section>

            <section id="development" class="section">
                <h2>Development</h2>
                <p>After checking out the repo, run <code>bin/setup</code> to install dependencies. Then, run <code>rake spec</code> to run the tests. You can also run <code>bin/console</code> for an interactive prompt that will allow you to experiment.</p>
                <p>To install this gem onto your local machine, run <code>bundle exec rake install</code>. To release a new version, update the version number in <code>version.rb</code>, and then run <code>bundle exec rake release</code>, which will create a git tag for the version, push git commits and the created tag, and push the <code>.gem</code> file to <a href="https://rubygems.org" target="_blank">rubygems.org</a>.</p>
            </section>

            <section id="contributing" class="section">
                <h2>Contributing</h2>
                <p>Bug reports and pull requests are welcome on GitHub at <a href="https://github.com/ismasan/steppe" target="_blank">https://github.com/ismasan/steppe</a>.</p>
            </section>

            <section id="license" class="section">
                <h2>License</h2>
                <p>The gem is available as open source under the terms of the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a>.</p>
            </section>
        </main>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/ruby.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
